# Author: Salvatore Santoro <sal.santoro@studenti.unina.it>
# Author: Vincenzo Maisto <vincenzo.maisto2@unina.it>
# Author: Giuseppe Capasso <giuseppe.capasso17@studenti.unina.it>
# Description: Parse PBUS config and generate HAL header

import csv
import sys
import os
import utils

# Check for correct number of arguments
if len(sys.argv) != 5:
    print("Usage: <CONFIG_PERIPHERALS_CSV> <CONFIG_MAIN_BUS_CSV> <CONFIG_HIGH_PERFORMANCE_BUS_CSV> <OUTPUT_HAL_CONF_FILE>")
    sys.exit(1)

config_file_names = sys.argv[1 : -1]
output_hal_conf_file = sys.argv[-1]

range_names = []
range_base_addr = []
range_addr_width = []
# List of device peripherals, needs to be a set to avoid duplicates
devices = set()

for fname in config_file_names:
    # Open the configuration files and parse them as csv
    with open(fname, "r") as file:
        reader = csv.reader(file)

        # next gets a single value
        protocol = utils.get_value_by_property(reader, "PROTOCOL")
        if protocol == "DISABLE":
            continue

        # read the rows we need
        names = utils.get_value_by_property(reader, "RANGE_NAMES").split(" ")
        base_addr = utils.get_value_by_property(reader, "RANGE_BASE_ADDR").split(" ")
        addr_width = utils.get_value_by_property(reader, "RANGE_ADDR_WIDTH").split(" ")

        # take peripherals and add them to the devices set
        if "peripheral" in fname:
            for name in names:
                # Use a generic TIM to enable timer driver
                if name.startswith("TIM"):
                    devices.add("TIM")
                else:
                    devices.add(name)

        # add the "Value" property to the correnspoding list
        range_names += names
        range_base_addr += base_addr
        range_addr_width += addr_width



assert len(range_names) == len(range_base_addr) == len(range_addr_width)
# build the peripheral list
peripherals = []
for name, addr, width in zip(range_names, range_base_addr, range_addr_width):
    # not a peripheral
    if name.endswith("BUS"):
        continue

    peripherals.append({
        "device": name,
        "base": int(addr, 16),
        "range": int(width)
    })

# Convert the set in a list
devices = list(devices)
# Extract base name and make it a valid macro name for the include guard
base_filename = os.path.basename(output_hal_conf_file).replace(".", "_").upper()
include_guard = f"__{base_filename}__"

hal_template_str = r"""/* File generated by {current_file_path} */

#ifndef {include_guard}
#define {include_guard}

#include <stdint.h>

// Address of configured peripherals
{peripheral_block}

// Enabled devices
{device_block}

#endif // {include_guard}
"""

# Creates a new string based on the device list. `devices` is a list of device objects
# {
#     "device": name,
#     "base": int(addr, 16),
#     "range": int(width)
# }
# Produces a C preprocessor define with:
# "#define <DEVICE_NAME>_IS_ENABLED 1"
lines = []
for d in sorted(devices):
    lines.append(f"#define {d.upper()}_IS_ENABLED 1")
device_block = "\n".join(lines)


# Creates a new string based on the device list. `devices` is a list of device objects
# {
#     "device": name,
#     "base": int(addr, 16),
#     "range": int(width)
# }
# Produces a C preprocessor define with:
# "#define _peripheral_DEVICE_NAME_start 0x{base}"
# "#define _peripheral_DEVICE_NAME_end   0x{base + 1 size}"
lines = []
for p in peripherals:
    name = p["device"]
    base = p["base"]
    size = p["range"]
    lines.append(f"#define _peripheral_{name}_start  0x{base:016x}u")
    lines.append(f"#define _peripheral_{name}_end    0x{base + (1 << size):016x}u")
peripheral_block = "\n".join(lines)


# The hal_template_str is a string which can be formatted (same as f-string). Provide {variable}
# as strings. This is why we call render_* functions
rendered = hal_template_str.format(
    current_file_path=os.path.basename(__file__),
    peripheral_block=peripheral_block,
    include_guard=include_guard,
    device_block=device_block,
)

# === Output to file ===
with open(output_hal_conf_file, "w") as f:
    f.write(rendered)
